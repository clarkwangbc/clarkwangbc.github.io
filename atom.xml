<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>诗酒趁年华</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-14T08:15:19.766Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>王炳程</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随机化完全区组设计 RCBD</title>
    <link href="http://yoursite.com/2019/08/13/%E9%9A%8F%E6%9C%BA%E5%8C%96%E5%AE%8C%E5%85%A8%E5%8C%BA%E7%BB%84%E8%AE%BE%E8%AE%A1-RCBD/"/>
    <id>http://yoursite.com/2019/08/13/随机化完全区组设计-RCBD/</id>
    <published>2019-08-13T12:23:01.000Z</published>
    <updated>2019-08-14T08:15:19.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本定义和概念"><a href="#基本定义和概念" class="headerlink" title="基本定义和概念"></a>基本定义和概念</h2><ol><li><strong>讨厌因子</strong>（nuisance factor）是一个可能对响应产生影响的设计因子，但是我们对之并不感兴趣。</li><li>当讨厌因子有时是<strong>未知</strong>且<strong>不可控</strong>时，我们采用<strong>随机化</strong>处理；当讨厌因子是<strong>已知</strong>但<strong>不可控</strong>时，我们采用<strong>协方差分析</strong>；当讨厌因子是<strong>已知</strong>且<strong>可控</strong>时，我们采用<strong>区组化（blocking</strong>）设计。</li><li>随机化完全区组设计（randomized complete block design）是指每一个区组内包含所有的处理。区组表示的是随机化约束。<a id="more"></a></li><li><p>RCBD 统计模型：</p><ul><li><p>效应模型 effect model</p><script type="math/tex; mode=display">y_i = \mu+\tau_i+\beta_j+\epsilon_{i,j} \left\{ \begin{array}{lr}i=1,2,..., a &\\ j=1,2,...,b\end{array}\right.</script></li><li><p>均值模型 </p><script type="math/tex; mode=display">y_i = \mu_{i,j}+\epsilon_{i,j}\left\{ \begin{array}{lr}i=1,2,..., a &\\ j=1,2,...,b\end{array}\right.</script></li><li><p>RCBD 方差分析等式</p><script type="math/tex; mode=display">SS = SS_{treatment}+SS_{blocks}+SS_E</script><p>其中自由度分别是 $ab-1$，$a-1$，$(a-1)(b-1)$。</p></li></ul></li><li>对区组的均值进行方差检验，其中<script type="math/tex">F_0 = \frac{MS_{blocks}}{MS_E}</script> 与<script type="math/tex">F_{a,a-1,(a-1)(b-1)}</script> 进行比较似乎可以验证假设<script type="math/tex">H_0:\beta_j=0</script> 。通常来说，方差分析F的检验只需要基于随机化就可以说明是合理的，无需正态性假设，但是这对比较区组的均值的检验却并不适用，实际上这里的F的比值是检验区组的均值的等式加随机化约束。但在实践中，F检验法可以作为研究区组变量效应的一种近似的方法，当这一比值较大时，可以说明区组因子有较大影响。</li><li>RCBD 是一种降噪设计技术，它能有效地增加数据中的信噪比，提高了处理均值比较的精度。</li></ol><h2 id="多重比较"><a href="#多重比较" class="headerlink" title="多重比较"></a>多重比较</h2><p>RCBD 多重比较的方法与标准的方差分析的方法类似，可以使用方差分析中任意一种多重比较的方法，只需要将其中的公式简单地用区组数（$b$）代替单因子完全随机化设计的重复次数（$n$）就可以了；此外，还要使用随机区组设计中误差的自由度数$(a-1)(b-1)$来代替完全随机化设计的误差自由度 $[a(n-1)]$。</p><h2 id="模型合适性检验"><a href="#模型合适性检验" class="headerlink" title="模型合适性检验"></a>模型合适性检验</h2><p>我们需要警惕那些由正态性假定、处理或者区组的不等的误差方差以及区组-处理交互作用引起的潜在问题。如同在完全随机化设计中那样，<strong>残差分析</strong>是用于这类诊断性检验的主要工作。</p><p>如果残差与预测值低是一条曲线，例如对于低的预测值，存在着产生负残差的趋势，对于中等的预测值，存在着产生正残差的趋势，而对于高预测值，则尊在产生负残差的趋势，则这类图像暗示着区组与处理间存在交互作用。</p><h2 id="随机完全化区组设计的其他方面"><a href="#随机完全化区组设计的其他方面" class="headerlink" title="随机完全化区组设计的其他方面"></a>随机完全化区组设计的其他方面</h2><ol><li><p>随机化区组模型的可加性：用于随机化区组设计的线性模型是<strong>可加</strong>的。</p></li><li><p>随机处理与区组：</p><ul><li>如果处理和区组是随机的，方法同样适用。不过在对结果进行解释时，需要做相应的更改。</li><li>在区组是随机的情况下，如果出现处理-区组的交互作用，则关于处理均值的检验不收交互作用的影响。这是因为出处理和误差的期望均方值<strong>二者</strong>都含有交互作用效应。</li></ul></li><li><p>样本量的选择：增加区组数会增大重复得到次数和误差的自由度，使得设计更加灵敏。关于随机化单因子设计的有关实验重复次数的方法仍然使用。只需注意自由度的问题。但增加区组数会增加实验成本，因此要权衡利弊，选择注意自由度的数值。</p></li><li><p>缺失值的估计：对于缺失值，一般有两种方法</p><ul><li>近似分析法：估计这一缺失值，并把它作为真实数据进行通常的方差分析，并将误差自由度减小1；但这一方法会产生有偏均方值，得出过多的显著性结论。</li><li>精确分析法：用一般回归的显著性检验法来精确分析</li></ul></li><li><p>一般回归的显著性检验法可以用来进行随机化完全区组设计的方差分析</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本定义和概念&quot;&gt;&lt;a href=&quot;#基本定义和概念&quot; class=&quot;headerlink&quot; title=&quot;基本定义和概念&quot;&gt;&lt;/a&gt;基本定义和概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;讨厌因子&lt;/strong&gt;（nuisance factor）是一个可能对响应产生影响的设计因子，但是我们对之并不感兴趣。&lt;/li&gt;
&lt;li&gt;当讨厌因子有时是&lt;strong&gt;未知&lt;/strong&gt;且&lt;strong&gt;不可控&lt;/strong&gt;时，我们采用&lt;strong&gt;随机化&lt;/strong&gt;处理；当讨厌因子是&lt;strong&gt;已知&lt;/strong&gt;但&lt;strong&gt;不可控&lt;/strong&gt;时，我们采用&lt;strong&gt;协方差分析&lt;/strong&gt;；当讨厌因子是&lt;strong&gt;已知&lt;/strong&gt;且&lt;strong&gt;可控&lt;/strong&gt;时，我们采用&lt;strong&gt;区组化（blocking&lt;/strong&gt;）设计。&lt;/li&gt;
&lt;li&gt;随机化完全区组设计（randomized complete block design）是指每一个区组内包含所有的处理。区组表示的是随机化约束。
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="实验设计" scheme="http://yoursite.com/tags/%E5%AE%9E%E9%AA%8C%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04关闭图形界面</title>
    <link href="http://yoursite.com/2019/07/09/Ubuntu18-04%E5%85%B3%E9%97%AD%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/"/>
    <id>http://yoursite.com/2019/07/09/Ubuntu18-04关闭图形界面/</id>
    <published>2019-07-09T09:41:36.000Z</published>
    <updated>2019-07-09T09:42:27.522Z</updated>
    
    <content type="html"><![CDATA[<p>在安装CUDA的时候，发现如果不关闭图形界面将无法安装。</p><p>但是网上提供的下述方法似乎在18.04失效了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service lightdm stop</span><br></pre></td></tr></table></figure><p>系统会提示 <code>lightdm.service not loaded</code></p><a id="more"></a><p>但是事实上，Ubuntu 18.04 中需要使用更加麻烦的方法，需要设置后重新启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">set</span>-default multi-user.target</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>重新开启图形界面如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">set</span>-default graphical.target</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在安装CUDA的时候，发现如果不关闭图形界面将无法安装。&lt;/p&gt;
&lt;p&gt;但是网上提供的下述方法似乎在18.04失效了：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo service lightdm stop&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;系统会提示 &lt;code&gt;lightdm.service not loaded&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Shadowsocks和SwitchOmega的安装与配置</title>
    <link href="http://yoursite.com/2019/07/09/Shadowsocks%E5%92%8CSwitchOmega%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/07/09/Shadowsocks和SwitchOmega的安装与配置/</id>
    <published>2019-07-09T08:27:28.000Z</published>
    <updated>2019-07-09T09:43:33.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shadowsocks-安装与配置"><a href="#shadowsocks-安装与配置" class="headerlink" title="shadowsocks 安装与配置"></a>shadowsocks 安装与配置</h2><ol><li><p>由于Shadowsocks没有我使用的服务的加密方式，因此需要使用Shadowsocks-libev，一个用C语言开发的Shadowsocks版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install shadowsocks-libev</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol><li><p>修改配置文件。先创建或者打开一个配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/shadowsocks-libev/config.json</span><br></pre></td></tr></table></figure><p>然后在打开的文件中填写相应的服务信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:[&quot;[::0]&quot;, &quot;0.0.0.0&quot;],</span><br><span class="line">    &quot;server_port&quot;:8388,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;barfoo!&quot;,</span><br><span class="line">    &quot;timeout&quot;:60,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-cfb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中需要修改的是server, server_port, password和method。其中需要注意server的格式，这样才能同时适配ipv4和ipv6。</p></li><li><p>启动服务。在终端中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss-local -c /etc/shadowsocks-libev/config.json &amp;</span><br></pre></td></tr></table></figure><p>其中<code>&amp;</code>表示在后台运行，可以去掉。</p></li><li><p>设置开机启动。我采用的方式是把该命令注册服务，首先创建并编辑文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/systemd/system/shadowsocks.service</span><br></pre></td></tr></table></figure><p>在文件中添加如下内容</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Shadowsocks Client Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=root</span><br><span class="line">ExecStart=/usr/bin/ss-local -c /etc/shadowsocks-libev/config.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后在终端中输入如下命令是配置生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> /etc/systemd/system/shadowsocks.service</span><br></pre></td></tr></table></figure></li></ol><h2 id="SwitchOmega的安装和配置"><a href="#SwitchOmega的安装和配置" class="headerlink" title="SwitchOmega的安装和配置"></a>SwitchOmega的安装和配置</h2><ol><li><p>安装SwitchOmega。有两种方法，一种是在浏览器的插件商店中安装，但是由于chrome的插件商店往往无法访问，可以采用第二种手动安装的方式。手动安装可以到SwitchOmega的<a href="https://github.com/FelisCatus/SwitchyOmega/releases" target="_blank" rel="noopener">Github上下载</a>，然后拖到chrome的插件页面中。不过这种方法不知道为什么我也没成功，提示说我下载的这个crx文件有问题？最后chrome是通过账号同步的方式自动同步我在别的电脑上安装的插件。</p><p>当然其实可以用Firefox，这个倒是没什么问题。</p></li><li><p>安装SwitchOmega后，打开它的配置界面，然后点击左侧的proxy。在右侧代理服务器中，修改代理协议为SOCKS5，代理服务器为127.0.0.1，代理端口为1080，然后别忘记点击左侧的<code>应用选项</code>。如下图所示：</p><p><img src="https://user-images.githubusercontent.com/3062168/60870090-bfceb300-a262-11e9-95a3-441a00467463.png" alt></p></li><li><p>然后点击左侧的auto switch，先点击<strong>规则列表设置</strong>，选择AutoProxy，在下面填写规则列表网址：</p><blockquote><p><a href="https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt，" target="_blank" rel="noopener">https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt，</a></p></blockquote><p> 然后点击按钮<code>立即更新情景模式</code>，稍等一会后下面的规则列表正文将会出现下载的文本。</p><p>然后在上面的<strong>切换规则</strong>中，删除最上面两个默认的规则，在下面一栏第一条的情景模式中选择proxy，第二条选择直接连接。最后点击<code>应用选项</code>即可。如下图所示：</p><p><img src="https://user-images.githubusercontent.com/3062168/60870776-0f61ae80-a264-11e9-9254-bbb096897011.png" alt></p></li><li><p>搞定以上内容后，我们现在可随便打开一个网址，例如scholar.google.com，然后点击插件栏中的SwitchOmega，切换至auto switch模式即可。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;shadowsocks-安装与配置&quot;&gt;&lt;a href=&quot;#shadowsocks-安装与配置&quot; class=&quot;headerlink&quot; title=&quot;shadowsocks 安装与配置&quot;&gt;&lt;/a&gt;shadowsocks 安装与配置&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;由于Shadowsocks没有我使用的服务的加密方式，因此需要使用Shadowsocks-libev，一个用C语言开发的Shadowsocks版本：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt install shadowsocks-libev&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="学习" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shadowsocks" scheme="http://yoursite.com/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Github 博客搭建</title>
    <link href="http://yoursite.com/2019/07/06/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/07/06/Hexo博客搭建/</id>
    <published>2019-07-06T11:50:39.000Z</published>
    <updated>2019-07-06T12:16:11.937Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo是一个基于Node.js的静态博客框架，安装简单，搭建方便。由于Hexo生成的是一个静态的网站，因此可以搭建在一些提供静态网站服务的地方，例如Github。所以整体来说这个轻量型的博客可以基本满足我的需求，但缺点就是不能随时更新博客，考虑到我的博客的更新频率，这也不会是太大的问题。</p><a id="more"></a><p>搭建步骤</p><ul><li>Github个人网站</li><li>安装Node.js 和 Hexo</li><li>建立博客</li><li>发布文章</li></ul><h2 id="Github-个人网站"><a href="#Github-个人网站" class="headerlink" title="Github 个人网站"></a>Github 个人网站</h2><p>在Github上新建一个仓库，仓库的名称取：用户名.github.io，例如我的用户名是clarkwangbc，因此这个仓库的名称就是clarkwangbc.github.io</p><p>然后需要讲Github与我的电脑连接起来，关于这一点，可以参考README.md中<strong>建立Git和Github的连接</strong>部分。</p><p>当然，确保你的电脑上安装了Git</p><h2 id="安装Node-js-和-Hexo"><a href="#安装Node-js-和-Hexo" class="headerlink" title="安装Node.js 和 Hexo"></a>安装Node.js 和 Hexo</h2><p>由于我的博客主要会在我的MacBook Pro上更新，因此以下的这些操作都是基于Mac的。</p><ol><li><p>安装Node Version Manager (nvm)</p><p>nvm 是一个开源的node.js多版本管理Bash工具，类似于Python中的pyenv工具，用于在Bash环境中随意切换已安装的node版本。目前nvm的版本是0.34.0，因此可以使用如下代码进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure><p>或者是Wget</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash</span><br></pre></td></tr></table></figure><p>具体可以参考<a href="https://github.com/nvm-sh/nvm#install-script" target="_blank" rel="noopener">官方指南</a>。</p></li><li><p>安装Node.js</p><p>使用nvm安装最新的Node.js</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install node</span><br></pre></td></tr></table></figure><p>nvm安装的可能不是Node官方推荐的稳定版本，因此建议参考官方推荐版本后安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 10.16.0</span><br></pre></td></tr></table></figure></li><li><p>安装Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li></ol><h2 id="建立博客"><a href="#建立博客" class="headerlink" title="建立博客"></a>建立博客</h2><p>安装hexo后，我们就可以建立我们的博客了。</p><ol><li><p>首先我们建立一个Blog的文件夹，然后在此文件夹内初始化我们的博客：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure></li><li><p>然后我们可以简单看一下我们的博客，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>然后我们用浏览器打开 <code>localhost:4000</code>就可以看到我们的博客了。</p></li><li><p>当然这样的博客可能太简陋了，我们可以选择一个我们喜欢的主题，例如Next。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>打开博客的根目录中的<code>_config.yml</code>文件，修改主题为next，并修改deploy信息如下</p><p>：</p><p><img src="https://user-images.githubusercontent.com/3062168/60755995-67ad6c00-a02a-11e9-8f73-2351aac6df82.png" alt></p><p>然后再打开<code>themes/next/_config.yml</code>文件，调整主题的各种参数，这里我把主题的风格改为Mist。</p><p><img src="https://user-images.githubusercontent.com/3062168/60756029-e904fe80-a02a-11e9-9072-74a6081231f9.png" alt></p></li><li><p>更换主题后，我们可以用如下命令来实时观看我们的修改效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure></li><li><p>在确认没有问题后，我们可以将博客推送到Github上。不过在此之前，我们得先安装一个部署到Github上的工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后就可以部署了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>有时候为了方便，我们会将生成和部署一起使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>成功后便可以在自己的Github Page上浏览了。</p></li></ol><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><ol><li><p>在命令行中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n <span class="string">"article_name"</span></span><br></pre></td></tr></table></figure><p>在博客根目录下<code>source/_post</code>中多出了一个叫<code>article_name.md</code>的文件，使用markdown的编辑器打开就可以进行书写。</p></li><li><p>书写完成后，命令行中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>便可推送了</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo是一个基于Node.js的静态博客框架，安装简单，搭建方便。由于Hexo生成的是一个静态的网站，因此可以搭建在一些提供静态网站服务的地方，例如Github。所以整体来说这个轻量型的博客可以基本满足我的需求，但缺点就是不能随时更新博客，考虑到我的博客的更新频率，这也不会是太大的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Git简易指南</title>
    <link href="http://yoursite.com/2019/07/06/Git%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2019/07/06/Git简易指南/</id>
    <published>2019-07-06T11:50:27.000Z</published>
    <updated>2019-07-06T11:54:01.508Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><strong>安装Git</strong></p><p>可以使用基础软件管理包:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><p>或者使用源码直接编译:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev</span><br></pre></td></tr></table></figure><p>更多的安装方式可以参考<a href="https://git-scm.com/book/zh/v2/起步-安装-Git" target="_blank" rel="noopener">链接</a>。</p></li></ol><a id="more"></a><ol><li><p><strong>创建新仓库</strong></p><p>创建新的文件夹，打开，然后执行以下命令创建新的git仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p><strong>检出仓库</strong></p><p>执行以下命令以创建一个本地仓库的克隆版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> /path/to/repository</span><br></pre></td></tr></table></figure><p>如果是远端服务器上的仓库，你的命令会是这个样子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> username@host:/path/to/repository</span><br></pre></td></tr></table></figure></li><li><p><strong>工作流</strong></p><p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 <code>工作目录</code>，它持有实际文件；第二个是 <code>缓存区（Index）</code>，它像个缓存区域，临时保存你的改动；最后是 <code>HEAD</code>，指向你最近一次提交后的结果。</p></li><li><p><strong>添加与提交</strong></p><p>你可以计划改动（把它们添加到缓存区），使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br><span class="line">git add *</span><br></pre></td></tr></table></figure><p>这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;代码提交信息&quot;</span><br></pre></td></tr></table></figure><p>现在，你的改动已经提交到了 <code>HEAD</code>，但是还没到你的远端仓库。</p></li><li><p><strong>推送改动</strong></p><p>你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>其中可以把 <em>master</em> 换成你想要推送的任何分支。</p><p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;server&gt;</span><br></pre></td></tr></table></figure><p>如此你就能够将你的改动推送到所添加的服务器上去了。</p></li><li><p><strong>分支</strong></p><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<em>master</em> 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p>创建一个叫做“feature_x”的分支，并切换过去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature_x</span><br></pre></td></tr></table></figure><p>切换回主分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>再把新建的分支删掉：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure><p>除非你将分支推送到远端仓库，不然该分支就是不为他人所见的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>更新与合并</strong></p><p>要更新你的本地仓库至最新改动，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>以在你的工作目录中 <strong>获取（fetch）</strong> 并 <strong>合并（merge）</strong> 远端的改动。<br>要合并其他分支到你的当前分支（例如 master），执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 <strong>冲突（conflicts）</strong>。 这时候就需要你修改这些文件来人肉合并这些 <strong>冲突（conflicts）</strong> 了。改完之后，你需要执行如下命令以将它们标记为合并成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>在合并改动之前，也可以使用如下命令查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>替换本地改动</strong></p><p>假如你做错事，你可以使用如下命令替换掉本地改动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。</p><p>假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><a href="https://www.bootcss.com/p/git-guide/" target="_blank" rel="noopener">原文链接</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;安装Git&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用基础软件管理包:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者使用源码直接编译:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;更多的安装方式可以参考&lt;a href=&quot;https://git-scm.com/book/zh/v2/起步-安装-Git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 搜狗拼音输入法候选乱码</title>
    <link href="http://yoursite.com/2019/07/05/Ubuntu-%E6%90%9C%E7%8B%97%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%B3%95%E5%80%99%E9%80%89%E4%B9%B1%E7%A0%81/"/>
    <id>http://yoursite.com/2019/07/05/Ubuntu-搜狗拼音输入法候选乱码/</id>
    <published>2019-07-05T11:46:47.000Z</published>
    <updated>2019-07-05T13:38:20.731Z</updated>
    
    <content type="html"><![CDATA[<p>终端输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.config</span><br><span class="line">sudo rm -rf SogouPY* sogou*</span><br></pre></td></tr></table></figure><p>然后注销即可(注意，这里必须是注销，不注销直接重启并不管用)</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终端输入如下命令：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd ~/.config&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo rm -rf SogouPY* sogou*&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后注销即可(注意，这里必须是注销，不注销直接重启并不管用)&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="输入法" scheme="http://yoursite.com/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装NVIDIA驱动</title>
    <link href="http://yoursite.com/2019/07/05/Ubuntu%E5%AE%89%E8%A3%85NVIDIA%E9%A9%B1%E5%8A%A8/"/>
    <id>http://yoursite.com/2019/07/05/Ubuntu安装NVIDIA驱动/</id>
    <published>2019-07-05T11:45:34.000Z</published>
    <updated>2019-07-09T08:33:09.048Z</updated>
    
    <content type="html"><![CDATA[<p>我最近在使用Ubuntu的时候，不知道为什么，系统隔三差五地掉显卡驱动，所以在这里把装驱动的流程记录下来，供以后使用。</p><a id="more"></a><h2 id="方法1：系统自动更新"><a href="#方法1：系统自动更新" class="headerlink" title="方法1：系统自动更新"></a>方法1：系统自动更新</h2><p>系统设置-&gt;软件更新-&gt;附加驱动-&gt;选择nvidia最新驱动-&gt;应用更改</p><h2 id="方法2：官网下载自行编译"><a href="#方法2：官网下载自行编译" class="headerlink" title="方法2：官网下载自行编译"></a>方法2：官网下载自行编译</h2><p>先在官网下载好对应的显卡驱动。</p><p>Nvidia中文官网是 <a href="http://www.nvidia.cn/page/home.html" target="_blank" rel="noopener">http://www.nvidia.cn/page/home.html</a></p><h3 id="1-打开终端，先删除旧的驱动"><a href="#1-打开终端，先删除旧的驱动" class="headerlink" title="1. 打开终端，先删除旧的驱动"></a>1. 打开终端，先删除旧的驱动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge nvidia*</span><br></pre></td></tr></table></figure><h3 id="2-禁用自带的-nouveau-nvidia-驱动"><a href="#2-禁用自带的-nouveau-nvidia-驱动" class="headerlink" title="2. 禁用自带的 nouveau nvidia 驱动"></a>2. 禁用自带的 nouveau nvidia 驱动</h3><p>首先通过以下命令创建一个文件 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/modprobe.d/blacklist-nouveau.conf</span><br></pre></td></tr></table></figure><p>然后添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure><p>再更新一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-initramfs -u</span><br></pre></td></tr></table></figure><p>修改后需要重启系统。确认下Nouveau是否已经被你干掉，使用命令： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep nouveau</span><br></pre></td></tr></table></figure><h3 id="3-重启系统至文本模式，关闭-X-Window"><a href="#3-重启系统至文本模式，关闭-X-Window" class="headerlink" title="3.重启系统至文本模式，关闭 X-Window"></a>3.重启系统至文本模式，关闭 X-Window</h3><p>也可先进入图形桌面再运行init 3进入文本模式，再安装下载的驱动就无问题。</p><p>首先我们需要结束x-window的服务，否则驱动将无法正常安装。</p><p>关闭X-Window，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service lightdm stop</span><br></pre></td></tr></table></figure><p>然后切换tty1控制台：Ctrl+Alt+F1即可。</p><h3 id="4-安装驱动"><a href="#4-安装驱动" class="headerlink" title="4.安装驱动"></a>4.安装驱动</h3><p>接下来就是最关键的一步了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./NVIDIA.run</span><br></pre></td></tr></table></figure><p>开始安装，安装过程比较快。<br>根据提示选择即可最后安装完毕后，重新启动X-Window：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service lightdm start</span><br></pre></td></tr></table></figure><p>然后Ctrl+Alt+F7进入图形界面；</p><p>最后测试一下是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvidia-smi</span><br><span class="line">nvidia-settings</span><br></pre></td></tr></table></figure><h2 id="方法3：添加官方ppa源"><a href="#方法3：添加官方ppa源" class="headerlink" title="方法3：添加官方ppa源"></a>方法3：添加官方ppa源</h2><p>快捷键ctrl+alt+T打开命令终端，加入官方ppa源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br></pre></td></tr></table></figure><p>需要输入密码并按enter键确认。之后刷新软件库并安装最新驱动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nvidia-367nvidia-settings nvidia-prime</span><br></pre></td></tr></table></figure><p>安装完成后通过下面命令查看是否安装成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvidia-settings</span><br></pre></td></tr></table></figure><p>注意安装完成后要重启，有如下效果则安装完成，否则就说明安装有问题，尝试关闭UEFI保护试试。</p><blockquote><p><a href="https://blog.csdn.net/u014682691/article/details/80605201" target="_blank" rel="noopener">原文链接</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我最近在使用Ubuntu的时候，不知道为什么，系统隔三差五地掉显卡驱动，所以在这里把装驱动的流程记录下来，供以后使用。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="驱动" scheme="http://yoursite.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何建立一个 Markdown Notebook</title>
    <link href="http://yoursite.com/2019/07/05/%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AAMarkdown-Notebook/"/>
    <id>http://yoursite.com/2019/07/05/如何建立一个Markdown-Notebook/</id>
    <published>2019-07-05T11:27:46.000Z</published>
    <updated>2019-07-05T13:37:59.115Z</updated>
    
    <content type="html"><![CDATA[<p>这是我个人的Markdown Notebook，主要记录我研究过程中有关编程开发的经验记录。之前我一直使用OneNote进行记录，但是OneNote对代码的支持太烂了，而且没有linux客户端，因此我决定使用Typora+Git+Github的方式来建立一个跨平台的个人笔记系统。</p><a id="more"></a><p>关于这个系统的建立，可以参见这个<a href="https://www.bilibili.com/read/cv2230341/" target="_blank" rel="noopener">链接</a>。</p><p>关于如何建立Git和Github的链接，可以参考这个<a href="https://www.cnblogs.com/woider/p/6533709.html" target="_blank" rel="noopener">链接</a>。</p><p>关于如何使用Github建立自己的图床，可以参考这个<a href="https://www.jianshu.com/p/33eeacac3344" target="_blank" rel="noopener">链接</a>。</p><p>接下来将会介绍整个笔记本的建立。</p><h2 id="建立自己GitHub的私有仓库"><a href="#建立自己GitHub的私有仓库" class="headerlink" title="建立自己GitHub的私有仓库"></a>建立自己GitHub的私有仓库</h2><ol><li><p>首先进入GitHub的官网，在个人仓库页面里，创建一个私人的仓库。如下图所示：</p><p><img src="https://user-images.githubusercontent.com/3062168/60719924-b17b5100-9f5b-11e9-9d88-00e9ea7b02ba.png" alt></p></li><li><p>然后进入项目页面，将该仓库克隆到本地。注意克隆到本地时，需要先进入到自己想要存该仓库的本地地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:...</span><br></pre></td></tr></table></figure></li><li><p>设置Typora的文件树视图，然后打开自己的仓库，就可以了。</p></li><li><p>使用Git推送笔记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;notes&quot;</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li><li><p>一些需要注意的地方</p><ul><li>新建文件、目录操作都可以在文件树视图里面进行，不小心关闭了软件，只需要打开最近打开的文件，目录树自动就加载出来了。</li><li>本地图片放到同级目录下，就可以使用相对路径引入，在本地看笔记很方便。</li><li>同步github比较麻烦，需要自己提交至github。而且笔记的分享功能没有了。</li></ul></li></ol><h2 id="建立Git和Github的连接"><a href="#建立Git和Github的连接" class="headerlink" title="建立Git和Github的连接"></a>建立Git和Github的连接</h2><ol><li><p>安装Git</p><ul><li><p>ubuntu安装Git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></li><li><p>查看Git版本信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git version</span><br></pre></td></tr></table></figure></li><li><p>配置Git用户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"name"</span></span><br><span class="line">git config --global user.email <span class="string">"name@email.com"</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>开启SSH服务</p><ul><li><p>Ubuntu安装SSH</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install ssh</span><br></pre></td></tr></table></figure></li><li><p>查看SSH服务状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -e | grep sshd</span><br></pre></td></tr></table></figure><p>会显示如下，其中sshd表示ssh-server已启动</p><p><img src="https://user-images.githubusercontent.com/3062168/60720005-f0a9a200-9f5b-11e9-8a08-b796c263e8cb.png" alt></p></li></ul></li><li><p>生成SSH Key</p><ul><li><p>使用命令查看 SSH Key 是否存在，若存在则忽略这一步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al ~/.ssh</span><br></pre></td></tr></table></figure></li><li><p>生成SSH Key，生成会让你填写 passphrase，连按三次回车跳过即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"name@email.com"</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>进入你刚才生成SSH Key的目录，查看 id_rsa 和 id_rsa.pub 文件</p></li><li><p>打开 id_rsa.pub 文件，并将内容复制到剪贴板</p></li><li><p>登录 GitHub，打开settings 页面，选择 SSH and GPG keys 选项，新建一个SSH key，名字可以随便起，然后将刚才复制的SSH Key粘贴到下面的key栏中，然后点击添加就完成了。添加之后mac/linux就可以建立本地的Git与Github的连接了。</p></li></ol><h2 id="使用Github建立图床"><a href="#使用Github建立图床" class="headerlink" title="使用Github建立图床"></a>使用Github建立图床</h2><ol><li><p>方法1：类似于建立私有仓库。图片使用git上传后，网页浏览复制图片URL，将URL中的blob替换成raw即可。</p></li><li><p>方法2：打开图片仓库，点击issue，拖拽需要上传的屠刀到issue的文本框内，等待上传完毕后，便会显示一个url，复制那个url就可以了。</p><p><img src="https://user-images.githubusercontent.com/499192/57450172-1a955f80-725e-11e9-9fed-267179bdab15.gif" alt></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我个人的Markdown Notebook，主要记录我研究过程中有关编程开发的经验记录。之前我一直使用OneNote进行记录，但是OneNote对代码的支持太烂了，而且没有linux客户端，因此我决定使用Typora+Git+Github的方式来建立一个跨平台的个人笔记系统。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/07/05/hello-world/"/>
    <id>http://yoursite.com/2019/07/05/hello-world/</id>
    <published>2019-07-05T11:10:24.000Z</published>
    <updated>2019-07-05T13:37:52.679Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉博士的第四年也快要结束，这也是我在清华的第八个年头，时光荏苒，我也不再年轻，却仍然一事无成，不由有些落寞。过去的日子湮灭在时光里，难以再寻觅，不禁有些可惜，遂想用此博客来记录接下来的点滴，而这也是Jasmine所一直期望我所做的。</p><a id="more"></a><p>所以这个博客，一方面能够帮助我记录我学术道路上一些心得和体会，另一方面我也会添加一些我个人的爱好和照片在里面。</p><p>我目前的研究内容主要是探索人工智能与人的交互，因此会涉及到人工智能的一些简单的开发，我并非计算机科班出生，有些方面的知识还会有些欠缺，因此可能会对网络上他人的一些内容进行重新整理并写在这里，供我自己以后参考学习；同时我还是在我的博客写写一些关于人机交互、人因工程、实验设计方面的知识。由于我之前有过一些虚拟现实和游戏相关的研究，可能也会在博客中谈谈自己的看法。</p><p>至于个人方面的内容，则纯粹是个人的爱好了。我比较喜欢打游戏和看电影，因此我会不定期的更新我对一些游戏的评测和电源的影评。我也比较喜欢动手拼装，所以也会有一些玩具和电脑的组装。有时候，我会和Jasmine一起外出游玩，如果拍到一些有趣的照片我也会放在这里。</p><p>这些算是我个人生活和学术一些记录，但如若能够对他人有些帮助，那也是非常值得的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉博士的第四年也快要结束，这也是我在清华的第八个年头，时光荏苒，我也不再年轻，却仍然一事无成，不由有些落寞。过去的日子湮灭在时光里，难以再寻觅，不禁有些可惜，遂想用此博客来记录接下来的点滴，而这也是Jasmine所一直期望我所做的。&lt;/p&gt;
    
    </summary>
    
      <category term="随感" scheme="http://yoursite.com/categories/%E9%9A%8F%E6%84%9F/"/>
    
    
      <category term="blog" scheme="http://yoursite.com/tags/blog/"/>
    
  </entry>
  
</feed>
